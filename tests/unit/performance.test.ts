/**
 * 성능 시스템 단위 테스트
 * Generated by test-generator.server.ts
 */
import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { createMockRequest, createMockSession } from '../setup';

describe('Performance Manager', () => {
  let performanceManager: any;

  beforeEach(async () => {
    const { getPerformanceManager } = await import('~/lib/performance/performance-manager.server');
    performanceManager = getPerformanceManager();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('runComprehensiveAnalysis', () => {
    it('should return comprehensive performance analysis', async () => {
      // Act
      const result = await performanceManager.runComprehensiveAnalysis();

      // Assert
      expect(result).toBeDefined();
      expect(result.overallScore).toBeGreaterThan(0);
      expect(result.bundleOptimization).toBeDefined();
      expect(result.databaseOptimization).toBeDefined();
      expect(result.imageOptimization).toBeDefined();
    });

    it('should handle analysis errors gracefully', async () => {
      // Arrange
      const mockAnalysis = jest.spyOn(performanceManager, 'runComprehensiveAnalysis');
      mockAnalysis.mockRejectedValue(new Error('Analysis failed'));

      // Act & Assert
      await expect(performanceManager.runComprehensiveAnalysis()).rejects.toThrow('Analysis failed');
    });

    it('should measure analysis duration', async () => {
      // Act
      const start = performance.now();
      await performanceManager.runComprehensiveAnalysis();
      const duration = performance.now() - start;

      // Assert
      expect(duration).toBeGreaterThan(0);
      expect(duration).toBeLessThan(10000); // Should complete within 10 seconds
    });
  });

  describe('runAutoOptimization', () => {
    it('should execute automatic optimizations', async () => {
      // Act
      const result = await performanceManager.runAutoOptimization();

      // Assert
      expect(result).toBeDefined();
      expect(result.improvementScore).toBeGreaterThanOrEqual(0);
      expect(Array.isArray(result.optimizations)).toBe(true);
    });

    it('should return improvement score between 0-100', async () => {
      // Act
      const result = await performanceManager.runAutoOptimization();

      // Assert
      expect(result.improvementScore).toBeGreaterThanOrEqual(0);
      expect(result.improvementScore).toBeLessThanOrEqual(100);
    });
  });

  describe('performance targets', () => {
    it('should get performance targets', () => {
      // Act
      const targets = performanceManager.getPerformanceTargets();

      // Assert
      expect(targets).toBeDefined();
      expect(targets.bundleSize).toBeDefined();
      expect(targets.loadTime).toBeDefined();
      expect(targets.firstContentfulPaint).toBeDefined();
    });

    it('should set performance targets', () => {
      // Arrange
      const newTargets = {
        bundleSize: 400,
        loadTime: 2500,
        firstContentfulPaint: 1200,
      };

      // Act
      performanceManager.setPerformanceTargets(newTargets);
      const updatedTargets = performanceManager.getPerformanceTargets();

      // Assert
      expect(updatedTargets.bundleSize).toBe(400);
      expect(updatedTargets.loadTime).toBe(2500);
      expect(updatedTargets.firstContentfulPaint).toBe(1200);
    });
  });
});

describe('Bundle Optimizer', () => {
  let bundleOptimizer: any;

  beforeEach(async () => {
    const { getBundleOptimizer } = await import('~/lib/performance/bundle-optimizer.server');
    bundleOptimizer = getBundleOptimizer();
  });

  describe('analyzeBundlePerformance', () => {
    it('should analyze bundle performance metrics', () => {
      // Act
      const analysis = bundleOptimizer.analyzeBundlePerformance();

      // Assert
      expect(analysis).toBeDefined();
      expect(typeof analysis).toBe('object');
    });
  });

  describe('preloadCriticalChunks', () => {
    it('should preload critical chunks successfully', async () => {
      // Act & Assert
      await expect(bundleOptimizer.preloadCriticalChunks()).resolves.not.toThrow();
    });
  });

  describe('loadModule', () => {
    it('should load modules with performance monitoring', async () => {
      // Arrange
      const modulePath = 'test-module';

      // Act & Assert
      await expect(bundleOptimizer.loadModule(modulePath)).resolves.toBeDefined();
    });

    it('should handle module loading errors', async () => {
      // Arrange
      const invalidModulePath = 'non-existent-module';

      // Act & Assert
      await expect(bundleOptimizer.loadModule(invalidModulePath)).rejects.toThrow();
    });
  });
});

describe('Database Optimizer', () => {
  let databaseOptimizer: any;

  beforeEach(async () => {
    const { getDatabaseOptimizer } = await import('~/lib/performance/database-optimizer.server');
    databaseOptimizer = getDatabaseOptimizer();
  });

  describe('generatePerformanceReport', () => {
    it('should generate database performance report', async () => {
      // Act
      const report = await databaseOptimizer.generatePerformanceReport();

      // Assert
      expect(report).toBeDefined();
      expect(typeof report).toBe('object');
    });
  });

  describe('analyzeIndexes', () => {
    it('should analyze database indexes', async () => {
      // Act
      const analysis = await databaseOptimizer.analyzeIndexes();

      // Assert
      expect(analysis).toBeDefined();
    });
  });

  describe('optimizeConnectionPool', () => {
    it('should optimize database connection pool', async () => {
      // Act
      const optimization = await databaseOptimizer.optimizeConnectionPool();

      // Assert
      expect(optimization).toBeDefined();
    });
  });

  describe('query optimization', () => {
    it('should execute optimized queries', async () => {
      // Arrange
      const queryKey = 'test-query';
      const mockQuery = jest.fn().mockResolvedValue({ data: 'test' });

      // Act
      const result = await databaseOptimizer.executeOptimizedQuery(queryKey, mockQuery);

      // Assert
      expect(result).toEqual({ data: 'test' });
      expect(mockQuery).toHaveBeenCalled();
    });

    it('should cache query results', async () => {
      // Arrange
      const queryKey = 'cache-test-query';
      const mockQuery = jest.fn().mockResolvedValue({ data: 'cached' });

      // Act
      await databaseOptimizer.executeOptimizedQuery(queryKey, mockQuery);
      await databaseOptimizer.executeOptimizedQuery(queryKey, mockQuery);

      // Assert
      expect(mockQuery).toHaveBeenCalledTimes(1); // Should be cached
    });
  });

  describe('cache management', () => {
    it('should invalidate query cache', async () => {
      // Act & Assert
      await expect(databaseOptimizer.invalidateQueryCache()).resolves.not.toThrow();
    });

    it('should invalidate specific cache patterns', async () => {
      // Arrange
      const pattern = 'user:*';

      // Act & Assert
      await expect(databaseOptimizer.invalidateQueryCache(pattern)).resolves.not.toThrow();
    });
  });
});

describe('Image Optimizer', () => {
  let imageOptimizer: any;

  beforeEach(async () => {
    const { getImageOptimizer } = await import('~/lib/performance/image-optimizer.server');
    imageOptimizer = getImageOptimizer();
  });

  describe('optimizeImage', () => {
    it('should optimize image with default options', async () => {
      // Arrange
      const inputPath = '/test/image.jpg';

      // Act
      const result = await imageOptimizer.optimizeImage(inputPath);

      // Assert
      expect(result).toBeDefined();
      expect(result.originalSize).toBeGreaterThan(0);
      expect(result.optimizedSize).toBeGreaterThan(0);
    });

    it('should handle different image formats', async () => {
      // Arrange
      const formats = ['/test/image.jpg', '/test/image.png', '/test/image.webp'];

      // Act & Assert
      for (const imagePath of formats) {
        await expect(imageOptimizer.optimizeImage(imagePath)).resolves.toBeDefined();
      }
    });

    it('should generate responsive images', async () => {
      // Arrange
      const inputPath = '/test/large-image.jpg';
      const options = { generateResponsive: true };

      // Act
      const result = await imageOptimizer.optimizeImage(inputPath, options);

      // Assert
      expect(result.responsiveImages).toBeDefined();
      expect(Array.isArray(result.responsiveImages)).toBe(true);
    });
  });

  describe('cleanupOldImages', () => {
    it('should clean up old optimized images', async () => {
      // Act
      const result = await imageOptimizer.cleanupOldImages();

      // Assert
      expect(result).toBeDefined();
      expect(result.deletedFiles).toBeGreaterThanOrEqual(0);
      expect(result.freedMB).toBeGreaterThanOrEqual(0);
    });
  });

  describe('image format conversion', () => {
    it('should convert images to WebP', async () => {
      // Arrange
      const inputPath = '/test/image.jpg';
      const options = { format: 'webp' };

      // Act
      const result = await imageOptimizer.optimizeImage(inputPath, options);

      // Assert
      expect(result.format).toBe('webp');
    });

    it('should convert images to AVIF when supported', async () => {
      // Arrange
      const inputPath = '/test/image.jpg';
      const options = { format: 'avif' };

      // Act
      const result = await imageOptimizer.optimizeImage(inputPath, options);

      // Assert
      expect(result.format).toBe('avif');
    });
  });
});

// Coverage target: 90%
// This test file covers:
// - Performance manager comprehensive analysis
// - Bundle optimization and module loading
// - Database query optimization and caching
// - Image optimization and format conversion
// - Cache management and cleanup operations
// - Error handling and edge cases